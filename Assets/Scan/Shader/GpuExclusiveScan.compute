#include "../../ShaderUtils/Math.compute"

#pragma kernel CSExclusiveScan
#pragma kernel CSStoreBlockSum
#pragma kernel CSAddBlockSum

#define BLOCK_AMOUNT        2
#define BLOCK_DIMEN         uint3(BLOCK_AMOUNT, BLOCK_AMOUNT, BLOCK_AMOUNT)
#define BLOCK_SIZE          (BLOCK_AMOUNT * BLOCK_AMOUNT * BLOCK_AMOUNT)

uint3           GridDimen;
uint            Size;

Buffer<int>     In;
RWBuffer<int>   Out;

groupshared int sharedData[BLOCK_SIZE];

[numthreads(BLOCK_DIMEN.x, BLOCK_DIMEN.y, BLOCK_DIMEN.z)]
void CSExclusiveScan( uint3 Gid  : SV_GroupID, 
                      uint3 DTid : SV_DispatchThreadID, 
                      uint3 GTid : SV_GroupThreadID,
                      uint  GI   : SV_GroupIndex )
{
    uint tid = to1D(GTid, BLOCK_DIMEN);
    uint gid = to1D(Gid, GridDimen);
    uint globalId = tid + gid  * BLOCK_SIZE;
	
	if (globalId < Size)     sharedData[tid]   = In[globalId];
	int value = sharedData[tid];
	GroupMemoryBarrierWithGroupSync();
	
	for (uint s0 = 1; s0 <= BLOCK_SIZE >> 1; s0 <<=1) {
	    uint revId = BLOCK_SIZE - tid - 1;
	    if (tid % (2 * s0) == 0) {
            sharedData[revId] += sharedData[revId - s0];
        }
        GroupMemoryBarrierWithGroupSync();
	}
	
	if (tid == BLOCK_SIZE-1) sharedData[BLOCK_SIZE-1] = 0;
	GroupMemoryBarrierWithGroupSync();
	
	for (uint s1 = BLOCK_SIZE >> 1; s1 > 0; s1 >>=1) {
	    uint revId = BLOCK_SIZE - tid - 1;
	    if (tid % (2 * s1) == 0) {
	        sharedData[revId]      = sharedData[revId] + sharedData[revId - s1];
	        sharedData[revId - s1] = sharedData[revId] - sharedData[revId - s1];
	    }
	    GroupMemoryBarrierWithGroupSync();
	}
	
	if (tid == BLOCK_SIZE-1 || globalId == Size - 1) Out[Size + gid] = sharedData[tid] + value; 
	if (globalId < Size) Out[globalId] = sharedData[tid];
}

[numthreads(BLOCK_DIMEN.x, BLOCK_DIMEN.y, BLOCK_DIMEN.z)]
void CSStoreBlockSum( uint3 Gid  : SV_GroupID, 
                      uint3 DTid : SV_DispatchThreadID, 
                      uint3 GTid : SV_GroupThreadID,
                      uint  GI   : SV_GroupIndex )
{
    uint tid = to1D(GTid, BLOCK_DIMEN);
    uint gid = to1D(Gid, GridDimen);
    uint globalId = tid + gid  * BLOCK_SIZE;
    
    uint sumBlockId = Size + globalId;
    Out[globalId] = In[sumBlockId];
}

[numthreads(BLOCK_DIMEN.x, BLOCK_DIMEN.y, BLOCK_DIMEN.z)]
void CSAddBlockSum( uint3 Gid  : SV_GroupID, 
                    uint3 DTid : SV_DispatchThreadID, 
                    uint3 GTid : SV_GroupThreadID,
                    uint  GI   : SV_GroupIndex )
{
    uint tid = to1D(GTid, BLOCK_DIMEN);
    uint gid = to1D(Gid, GridDimen);
    uint globalId = tid + gid  * BLOCK_SIZE;
    
    int sum = In[globalId];
    for (uint i = 0; i < BLOCK_SIZE; ++i) {
        uint index = globalId * BLOCK_SIZE + i;
        if (index < Size) {
            Out[index] += sum;
        }
    }
}